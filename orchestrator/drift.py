"""
Advanced Drift Detection (TIRS)
================================
Temporal Intent Risk & Simulation - tracks behavior drift over time.
"""

import math
from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List, Tuple
from datetime import datetime, timedelta
from enum import Enum
from collections import deque
import json
import logging

logger = logging.getLogger("Orchestrator.Drift")


class DriftLevel(Enum):
    """Level of detected drift."""
    NONE = "none"          # Within normal bounds
    LOW = "low"            # Minor deviation
    MEDIUM = "medium"      # Concerning deviation
    HIGH = "high"          # Significant drift
    CRITICAL = "critical"  # Immediate intervention required


class AlertType(Enum):
    """Type of drift alert."""
    RISK_THRESHOLD = "risk_threshold"
    VELOCITY_SPIKE = "velocity_spike"
    PATTERN_ANOMALY = "pattern_anomaly"
    POLICY_CASCADE = "policy_cascade"
    CUMULATIVE_DRIFT = "cumulative_drift"
    BEHAVIOR_CHANGE = "behavior_change"


@dataclass
class DriftEvent:
    """A single drift event."""
    event_id: str
    timestamp: datetime
    agent_id: str
    action: str
    risk_delta: float
    cumulative_risk: float
    drift_level: DriftLevel
    context: Dict[str, Any] = field(default_factory=dict)


@dataclass
class DriftAlert:
    """An alert generated by drift detection."""
    alert_id: str
    alert_type: AlertType
    severity: DriftLevel
    agent_id: str
    pipeline_id: str
    message: str
    recommendation: str
    triggered_at: datetime = field(default_factory=datetime.now)
    acknowledged: bool = False
    acknowledged_at: Optional[datetime] = None
    acknowledged_by: Optional[str] = None

    def to_dict(self) -> Dict:
        return {
            "alert_id": self.alert_id,
            "alert_type": self.alert_type.value,
            "severity": self.severity.value,
            "agent_id": self.agent_id,
            "pipeline_id": self.pipeline_id,
            "message": self.message,
            "recommendation": self.recommendation,
            "triggered_at": self.triggered_at.isoformat(),
            "acknowledged": self.acknowledged
        }


@dataclass
class AgentBehaviorProfile:
    """Tracks behavioral patterns for an agent."""
    agent_id: str
    created_at: datetime = field(default_factory=datetime.now)

    # Risk metrics
    base_risk: float = 0.0       # Baseline risk level
    current_risk: float = 0.0    # Current risk level
    peak_risk: float = 0.0       # Highest risk observed
    avg_risk: float = 0.0        # Rolling average risk

    # Activity metrics
    total_actions: int = 0
    successful_actions: int = 0
    blocked_actions: int = 0
    escalated_actions: int = 0

    # Temporal patterns
    actions_per_hour: float = 0.0
    avg_action_interval: float = 0.0  # seconds
    last_action_time: Optional[datetime] = None

    # Risk history (sliding window)
    risk_history: List[Tuple[datetime, float]] = field(default_factory=list)
    risk_window_size: int = 100

    # Anomaly detection
    action_counts: Dict[str, int] = field(default_factory=dict)
    typical_actions: List[str] = field(default_factory=list)

    def record_action(self, action: str, risk_delta: float, blocked: bool = False, escalated: bool = False):
        """Record an action and update metrics."""
        now = datetime.now()
        self.total_actions += 1

        if blocked:
            self.blocked_actions += 1
        elif escalated:
            self.escalated_actions += 1
        else:
            self.successful_actions += 1

        # Update risk
        self.current_risk += risk_delta
        self.peak_risk = max(self.peak_risk, self.current_risk)

        # Update risk history
        self.risk_history.append((now, self.current_risk))
        if len(self.risk_history) > self.risk_window_size:
            self.risk_history = self.risk_history[-self.risk_window_size:]

        # Calculate rolling average
        if self.risk_history:
            self.avg_risk = sum(r for _, r in self.risk_history) / len(self.risk_history)

        # Update temporal metrics
        if self.last_action_time:
            interval = (now - self.last_action_time).total_seconds()
            if self.avg_action_interval == 0:
                self.avg_action_interval = interval
            else:
                self.avg_action_interval = (self.avg_action_interval * 0.9) + (interval * 0.1)

        self.last_action_time = now

        # Track action patterns
        self.action_counts[action] = self.action_counts.get(action, 0) + 1

    def get_action_velocity(self, window_minutes: int = 5) -> float:
        """Get actions per minute in recent window."""
        cutoff = datetime.now() - timedelta(minutes=window_minutes)
        recent = [r for t, r in self.risk_history if t > cutoff]
        if not recent:
            return 0.0
        return len(recent) / window_minutes

    def get_risk_trend(self, window_size: int = 10) -> str:
        """Get risk trend: increasing, decreasing, or stable."""
        if len(self.risk_history) < window_size:
            return "unknown"

        recent = [r for _, r in self.risk_history[-window_size:]]
        first_half = sum(recent[:len(recent)//2]) / (len(recent)//2)
        second_half = sum(recent[len(recent)//2:]) / (len(recent) - len(recent)//2)

        diff = second_half - first_half
        if diff > 0.05:
            return "increasing"
        elif diff < -0.05:
            return "decreasing"
        return "stable"

    def is_anomalous_action(self, action: str) -> bool:
        """Check if action is unusual for this agent."""
        if self.total_actions < 10:
            return False  # Not enough data

        if action not in self.action_counts:
            return True  # Never seen before

        # Check if action is rare (< 5% of total)
        action_ratio = self.action_counts[action] / self.total_actions
        return action_ratio < 0.05

    def to_dict(self) -> Dict:
        return {
            "agent_id": self.agent_id,
            "current_risk": self.current_risk,
            "peak_risk": self.peak_risk,
            "avg_risk": self.avg_risk,
            "total_actions": self.total_actions,
            "successful_actions": self.successful_actions,
            "blocked_actions": self.blocked_actions,
            "escalated_actions": self.escalated_actions,
            "actions_per_hour": self.actions_per_hour,
            "risk_trend": self.get_risk_trend(),
            "top_actions": sorted(
                self.action_counts.items(),
                key=lambda x: x[1],
                reverse=True
            )[:5]
        }


@dataclass
class PipelineDriftState:
    """Tracks drift state for a pipeline."""
    pipeline_id: str
    created_at: datetime = field(default_factory=datetime.now)

    # Risk tracking
    cumulative_risk: float = 0.0
    max_single_risk: float = 0.0
    risk_events: List[DriftEvent] = field(default_factory=list)

    # Thresholds
    warn_threshold: float = 0.3
    block_threshold: float = 0.5
    kill_threshold: float = 0.7

    # Policy cascades
    consecutive_blocks: int = 0
    consecutive_escalations: int = 0

    # State
    drift_level: DriftLevel = DriftLevel.NONE
    is_paused: bool = False
    is_killed: bool = False

    def add_risk_event(self, event: DriftEvent):
        """Add a risk event and update state."""
        self.risk_events.append(event)
        self.cumulative_risk += event.risk_delta
        self.max_single_risk = max(self.max_single_risk, event.risk_delta)

        # Update drift level
        if self.cumulative_risk >= self.kill_threshold:
            self.drift_level = DriftLevel.CRITICAL
            self.is_killed = True
        elif self.cumulative_risk >= self.block_threshold:
            self.drift_level = DriftLevel.HIGH
            self.is_paused = True
        elif self.cumulative_risk >= self.warn_threshold:
            self.drift_level = DriftLevel.MEDIUM
        elif self.cumulative_risk > 0.1:
            self.drift_level = DriftLevel.LOW
        else:
            self.drift_level = DriftLevel.NONE

    def record_block(self):
        """Record a blocked action."""
        self.consecutive_blocks += 1
        self.consecutive_escalations = 0

    def record_escalation(self):
        """Record an escalated action."""
        self.consecutive_escalations += 1

    def record_success(self):
        """Record a successful action - reduces consecutive counts."""
        self.consecutive_blocks = max(0, self.consecutive_blocks - 1)
        self.consecutive_escalations = max(0, self.consecutive_escalations - 1)

    def should_cascade_pause(self) -> bool:
        """Check if consecutive issues warrant a pause."""
        return self.consecutive_blocks >= 3 or self.consecutive_escalations >= 2

    def get_risk_velocity(self) -> float:
        """Get rate of risk accumulation."""
        if len(self.risk_events) < 2:
            return 0.0

        first = self.risk_events[0]
        last = self.risk_events[-1]
        duration = (last.timestamp - first.timestamp).total_seconds()

        if duration == 0:
            return 0.0

        return self.cumulative_risk / (duration / 60)  # risk per minute


class DriftDetector:
    """
    Advanced drift detection engine.

    Monitors agent behavior and pipeline execution to detect:
    - Risk threshold breaches
    - Velocity spikes (sudden increase in risky actions)
    - Pattern anomalies (unusual actions for an agent)
    - Policy cascades (consecutive policy violations)
    - Cumulative drift (gradual risk accumulation)
    - Behavior changes (deviation from baseline)
    """

    def __init__(self):
        self.agent_profiles: Dict[str, AgentBehaviorProfile] = {}
        self.pipeline_states: Dict[str, PipelineDriftState] = {}
        self.alerts: List[DriftAlert] = []
        self.alert_counter = 0

        # Thresholds
        self.risk_warn = 0.3
        self.risk_block = 0.5
        self.risk_kill = 0.7
        self.velocity_spike_threshold = 0.5  # risk per minute
        self.cascade_threshold = 3  # consecutive issues

        logger.info("Drift Detector initialized")

    def get_or_create_profile(self, agent_id: str) -> AgentBehaviorProfile:
        """Get or create agent behavior profile."""
        if agent_id not in self.agent_profiles:
            self.agent_profiles[agent_id] = AgentBehaviorProfile(agent_id=agent_id)
        return self.agent_profiles[agent_id]

    def get_or_create_state(self, pipeline_id: str) -> PipelineDriftState:
        """Get or create pipeline drift state."""
        if pipeline_id not in self.pipeline_states:
            self.pipeline_states[pipeline_id] = PipelineDriftState(
                pipeline_id=pipeline_id,
                warn_threshold=self.risk_warn,
                block_threshold=self.risk_block,
                kill_threshold=self.risk_kill
            )
        return self.pipeline_states[pipeline_id]

    def record_action(
        self,
        pipeline_id: str,
        agent_id: str,
        action: str,
        risk_delta: float,
        blocked: bool = False,
        escalated: bool = False,
        context: Dict = None
    ) -> Tuple[DriftLevel, List[DriftAlert]]:
        """
        Record an action and check for drift.

        Returns:
            Tuple of (drift_level, new_alerts)
        """
        profile = self.get_or_create_profile(agent_id)
        state = self.get_or_create_state(pipeline_id)
        new_alerts = []

        # Update profile
        profile.record_action(action, risk_delta, blocked, escalated)

        # Create drift event
        event = DriftEvent(
            event_id=f"drift_{self.alert_counter}",
            timestamp=datetime.now(),
            agent_id=agent_id,
            action=action,
            risk_delta=risk_delta,
            cumulative_risk=state.cumulative_risk + risk_delta,
            drift_level=state.drift_level,
            context=context or {}
        )

        # Update state
        state.add_risk_event(event)

        if blocked:
            state.record_block()
        elif escalated:
            state.record_escalation()
        else:
            state.record_success()

        # Check for various drift conditions
        new_alerts.extend(self._check_risk_threshold(state, agent_id, pipeline_id))
        new_alerts.extend(self._check_velocity_spike(state, profile, agent_id, pipeline_id))
        new_alerts.extend(self._check_pattern_anomaly(profile, action, agent_id, pipeline_id))
        new_alerts.extend(self._check_policy_cascade(state, agent_id, pipeline_id))
        new_alerts.extend(self._check_behavior_change(profile, agent_id, pipeline_id))

        # Store alerts
        self.alerts.extend(new_alerts)

        return state.drift_level, new_alerts

    def _create_alert(
        self,
        alert_type: AlertType,
        severity: DriftLevel,
        agent_id: str,
        pipeline_id: str,
        message: str,
        recommendation: str
    ) -> DriftAlert:
        """Create a new alert."""
        self.alert_counter += 1
        return DriftAlert(
            alert_id=f"alert_{self.alert_counter:04d}",
            alert_type=alert_type,
            severity=severity,
            agent_id=agent_id,
            pipeline_id=pipeline_id,
            message=message,
            recommendation=recommendation
        )

    def _check_risk_threshold(
        self,
        state: PipelineDriftState,
        agent_id: str,
        pipeline_id: str
    ) -> List[DriftAlert]:
        """Check for risk threshold breaches."""
        alerts = []

        if state.is_killed and not any(
            a.alert_type == AlertType.RISK_THRESHOLD and
            a.severity == DriftLevel.CRITICAL and
            a.pipeline_id == pipeline_id
            for a in self.alerts
        ):
            alerts.append(self._create_alert(
                AlertType.RISK_THRESHOLD,
                DriftLevel.CRITICAL,
                agent_id,
                pipeline_id,
                f"CRITICAL: Pipeline risk {state.cumulative_risk:.2f} exceeds kill threshold {state.kill_threshold}",
                "Pipeline has been killed. Requires manual review and restart."
            ))

        elif state.is_paused and not any(
            a.alert_type == AlertType.RISK_THRESHOLD and
            a.severity == DriftLevel.HIGH and
            a.pipeline_id == pipeline_id
            for a in self.alerts
        ):
            alerts.append(self._create_alert(
                AlertType.RISK_THRESHOLD,
                DriftLevel.HIGH,
                agent_id,
                pipeline_id,
                f"HIGH: Pipeline risk {state.cumulative_risk:.2f} exceeds block threshold {state.block_threshold}",
                "Pipeline has been paused. Review pending actions before continuing."
            ))

        elif state.drift_level == DriftLevel.MEDIUM and not any(
            a.alert_type == AlertType.RISK_THRESHOLD and
            a.severity == DriftLevel.MEDIUM and
            a.pipeline_id == pipeline_id
            for a in self.alerts[-10:]  # Check recent alerts
        ):
            alerts.append(self._create_alert(
                AlertType.RISK_THRESHOLD,
                DriftLevel.MEDIUM,
                agent_id,
                pipeline_id,
                f"WARNING: Pipeline risk {state.cumulative_risk:.2f} exceeds warn threshold {state.warn_threshold}",
                "Monitor closely. Consider reducing scope or adding approvals."
            ))

        return alerts

    def _check_velocity_spike(
        self,
        state: PipelineDriftState,
        profile: AgentBehaviorProfile,
        agent_id: str,
        pipeline_id: str
    ) -> List[DriftAlert]:
        """Check for sudden velocity spikes."""
        velocity = state.get_risk_velocity()

        if velocity > self.velocity_spike_threshold:
            # Check if we already alerted recently
            recent_velocity_alerts = [
                a for a in self.alerts[-5:]
                if a.alert_type == AlertType.VELOCITY_SPIKE and
                a.pipeline_id == pipeline_id
            ]
            if not recent_velocity_alerts:
                return [self._create_alert(
                    AlertType.VELOCITY_SPIKE,
                    DriftLevel.HIGH,
                    agent_id,
                    pipeline_id,
                    f"Risk velocity spike: {velocity:.3f}/min (threshold: {self.velocity_spike_threshold})",
                    "Slow down pipeline execution. Consider adding delays between actions."
                )]

        return []

    def _check_pattern_anomaly(
        self,
        profile: AgentBehaviorProfile,
        action: str,
        agent_id: str,
        pipeline_id: str
    ) -> List[DriftAlert]:
        """Check for unusual action patterns."""
        if profile.is_anomalous_action(action):
            return [self._create_alert(
                AlertType.PATTERN_ANOMALY,
                DriftLevel.MEDIUM,
                agent_id,
                pipeline_id,
                f"Unusual action for {agent_id}: '{action}' (not in typical pattern)",
                "Verify this action is intended. May indicate prompt injection or misconfiguration."
            )]

        return []

    def _check_policy_cascade(
        self,
        state: PipelineDriftState,
        agent_id: str,
        pipeline_id: str
    ) -> List[DriftAlert]:
        """Check for cascading policy violations."""
        if state.should_cascade_pause():
            return [self._create_alert(
                AlertType.POLICY_CASCADE,
                DriftLevel.HIGH,
                agent_id,
                pipeline_id,
                f"Policy cascade: {state.consecutive_blocks} blocks, {state.consecutive_escalations} escalations",
                "Multiple consecutive policy violations. Review pipeline configuration."
            )]

        return []

    def _check_behavior_change(
        self,
        profile: AgentBehaviorProfile,
        agent_id: str,
        pipeline_id: str
    ) -> List[DriftAlert]:
        """Check for behavior changes from baseline."""
        trend = profile.get_risk_trend()

        if trend == "increasing" and profile.current_risk > profile.avg_risk * 1.5:
            # Check for recent behavior alerts
            recent = [
                a for a in self.alerts[-10:]
                if a.alert_type == AlertType.BEHAVIOR_CHANGE and
                a.agent_id == agent_id
            ]
            if not recent:
                return [self._create_alert(
                    AlertType.BEHAVIOR_CHANGE,
                    DriftLevel.MEDIUM,
                    agent_id,
                    pipeline_id,
                    f"Behavior change: Risk trend increasing, current {profile.current_risk:.2f} > avg {profile.avg_risk:.2f}",
                    "Agent risk is trending upward. Review recent actions."
                )]

        return []

    def get_pipeline_drift(self, pipeline_id: str) -> Dict:
        """Get drift information for a pipeline."""
        state = self.pipeline_states.get(pipeline_id)
        if not state:
            return {
                "drift_level": DriftLevel.NONE.value,
                "cumulative_risk": 0.0,
                "is_paused": False,
                "is_killed": False
            }

        return {
            "drift_level": state.drift_level.value,
            "cumulative_risk": state.cumulative_risk,
            "max_single_risk": state.max_single_risk,
            "is_paused": state.is_paused,
            "is_killed": state.is_killed,
            "consecutive_blocks": state.consecutive_blocks,
            "consecutive_escalations": state.consecutive_escalations,
            "risk_velocity": state.get_risk_velocity(),
            "event_count": len(state.risk_events)
        }

    def get_agent_drift(self, agent_id: str) -> Dict:
        """Get drift information for an agent."""
        profile = self.agent_profiles.get(agent_id)
        if not profile:
            return {"agent_id": agent_id, "status": "no_data"}

        return profile.to_dict()

    def get_alerts(self, unacknowledged_only: bool = False) -> List[DriftAlert]:
        """Get all alerts, optionally filtering to unacknowledged."""
        if unacknowledged_only:
            return [a for a in self.alerts if not a.acknowledged]
        return self.alerts

    def acknowledge_alert(self, alert_id: str, user_id: str) -> bool:
        """Acknowledge an alert."""
        for alert in self.alerts:
            if alert.alert_id == alert_id:
                alert.acknowledged = True
                alert.acknowledged_at = datetime.now()
                alert.acknowledged_by = user_id
                return True
        return False

    def reset_pipeline_drift(self, pipeline_id: str):
        """Reset drift state for a pipeline."""
        if pipeline_id in self.pipeline_states:
            del self.pipeline_states[pipeline_id]

    def get_summary(self) -> Dict:
        """Get drift detection summary."""
        total_alerts = len(self.alerts)
        unack_alerts = len([a for a in self.alerts if not a.acknowledged])

        severity_counts = {}
        for level in DriftLevel:
            severity_counts[level.value] = len([
                a for a in self.alerts if a.severity == level
            ])

        return {
            "total_alerts": total_alerts,
            "unacknowledged_alerts": unack_alerts,
            "alerts_by_severity": severity_counts,
            "active_pipelines": len(self.pipeline_states),
            "monitored_agents": len(self.agent_profiles),
            "paused_pipelines": len([
                s for s in self.pipeline_states.values() if s.is_paused
            ]),
            "killed_pipelines": len([
                s for s in self.pipeline_states.values() if s.is_killed
            ])
        }


# Singleton
_drift_detector = None

def get_drift_detector() -> DriftDetector:
    global _drift_detector
    if _drift_detector is None:
        _drift_detector = DriftDetector()
    return _drift_detector
